<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Adobe Stock Metadata Generator</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --bg-primary-light: #f4f7f9;
            --bg-secondary-light: #ffffff;
            --text-primary-light: #2c3e50;
            --text-secondary-light: #707B89; 
            --accent-primary-light: #3498db; 
            --accent-info-light: #1abc9c;   /* Teal for Regenerate button */
            --accent-danger-light: #e74c3c;  /* Red for Remove button */
            --accent-success-light: #2ecc71; 
            --border-color-light: #e0e6ed;
            --shadow-color-light: rgba(44, 62, 80, 0.1);
            --border-radius-main: 8px;
            --card-editable-bg: #f7f8fa; 
            --card-editable-border: #dfe3e8; 
        }

        html.lenis { height: auto; }
        .lenis.lenis-smooth { scroll-behavior: auto !important; }
        .lenis.lenis-smooth [data-lenis-prevent] { overscroll-behavior: contain; }
        .lenis.lenis-stopped { overflow: hidden; }

        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'Inter', sans-serif; background-color: var(--bg-primary-light);
            color: var(--text-primary-light); font-size: 14px; 
            line-height: 1.6; 
            padding: 20px; 
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
        }
        .container { 
            max-width: 1200px; 
            margin: 15px auto; 
            background-color: transparent;
            opacity: 0; 
        }
        .container > h1 {
            text-align: center; font-size: 2em; 
            font-weight: 700;
            color: var(--accent-primary-light); margin-bottom: 25px; 
        }
        .section {
            background: var(--bg-secondary-light); padding: 25px; 
            border-radius: var(--border-radius-main); box-shadow: 0 3px 10px var(--shadow-color-light); 
            margin-bottom: 25px; 
        }
        .section h2 {
            font-size: 1.4em; 
            font-weight: 600; color: var(--text-primary-light);
            margin-bottom: 20px; 
            padding-bottom: 12px; 
            border-bottom: 1px solid var(--border-color-light);
        }
        .image-upload-section > h2 { /* Changed from .media-upload-section for consistency */
            border-bottom: none;
        }
        
        .form-group { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .form-group input[type="text"]#api-key-input {
            flex-grow: 1; padding: 10px 12px; 
            font-size: 0.95em;
            border: 1px solid var(--border-color-light);
            border-radius: var(--border-radius-main);
        }
        .form-group input[type="text"]#api-key-input:focus { border-color: var(--accent-primary-light); outline: none; box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15); }
        
        .api-key-list { display: flex; flex-direction: column; gap: 10px; }
        .api-key-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 15px; background-color: #f8f9fa;
            border: 1px solid var(--border-color-light); border-radius: 6px;
            transition: background-color 0.2s, border-left-color 0.2s, box-shadow 0.2s; cursor: pointer;
        }
        .api-key-item:hover { background-color: #f1f3f5; box-shadow: 0 1px 3px var(--shadow-color-light); }
        .api-key-item.active-api-key { background-color: #e9f3ff; border-left: 4px solid var(--accent-primary-light); font-weight: 500; }
        .api-key-item span:first-child { display: flex; align-items: center; gap: 8px; font-family: monospace; font-size: 0.9em; }
        .api-key-item span:first-child::before { content: ''; display: inline-block; width: 8px; height: 8px; border-radius: 50%; background-color: #ced4da; margin-right: 4px; }
        .api-key-item.active-api-key span:first-child::before { background-color: var(--accent-primary-light); }

        .generation-settings-section { padding-bottom: 15px; }
        .generation-settings-section .settings-header-wrapper {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;
        }
        .generation-settings-section .settings-header-wrapper p {
             font-size: 0.85em; color: var(--text-secondary-light); margin: 0;
        }
        .settings-groups-container {
            display: flex; flex-wrap: wrap; gap: 15px; 
            justify-content: space-around; align-items: flex-start; 
            border: 1px solid var(--border-color-light);
            padding: 15px; border-radius: var(--border-radius-main);
            background-color: #fbfdff;
        }
        .settings-group {
            background-color: transparent; padding: 0; border: none; 
            flex: 1 1 auto; min-width: 180px; 
        }
        .settings-group h4 {
            font-size: 0.95em; font-weight: 600;
            color: var(--accent-primary-light); margin-bottom: 10px; 
            padding-bottom: 6px; border-bottom: 1px solid #eef2f5;
        }
        .setting-field, .setting-field-checkbox {
            display: flex; align-items: center; margin-bottom: 8px; gap: 8px;
        }
        .setting-field label, .setting-field-checkbox label {
            font-size: 0.9em; color: var(--text-secondary-light);
            flex-basis: 70px; flex-shrink: 0;
        }
        .setting-field-checkbox label {
             flex-basis: auto; color: var(--text-primary-light); cursor: pointer;
        }
        .setting-field input[type="number"] {
            padding: 6px 8px; font-size: 0.9em; width: 60px; 
            border: 1px solid var(--border-color-light); border-radius: 4px;
        }
        .setting-field input[type="number"]:focus { border-color: var(--accent-primary-light); outline: none; box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1); }
        .setting-field-checkbox input[type="checkbox"] {
            width: 15px; height: 15px; accent-color: var(--accent-primary-light);
        }
        .settings-group small { font-size: 0.75em; margin-top: 5px; color: #82909a; }

        .dropzone {
            padding: 35px; border-radius: 6px;
            border: 2px dashed var(--border-color-light);
            background-color: var(--bg-primary-light); 
            text-align: center; min-height: 180px; 
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; margin-bottom: 25px;
        }
        .dropzone i.fa-cloud-upload-alt {
            font-size: 3em; color: var(--accent-primary-light);
            margin-bottom: 15px;
        }
        .dropzone p {
            margin: 0; color: var(--text-secondary-light);
            font-size: 1em;
        }
        
        .image-preview-container { /* Renamed to media-preview-container in thought process, but keeping class for less CSS change */
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; 
        }
        .image-card { /* Renamed to media-card in thought process */
            background: var(--bg-secondary-light);
            border-radius: 6px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.07); 
            border: 1px solid var(--card-editable-border); 
            overflow: hidden; display: flex; flex-direction: column;
            transition: box-shadow 0.3s ease, transform 0.3s ease;
            opacity:0; transform: scale(0.95); 
        }
        .image-card:hover { box-shadow: 0 4px 12px rgba(0,0,0,0.1); transform: translateY(-4px); }
        
        /* Styles for actual image OR video placeholder */
        .image-card img, .image-card .media-placeholder { 
            height: 160px; width: 100%; 
            object-fit: cover; cursor: default; 
            border-bottom: 1px solid var(--card-editable-border);
        }
        .image-card .media-placeholder { /* Specific for video placeholder */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--card-editable-bg); /* Light grey background */
        }
        .image-card .media-placeholder i {
            font-size: 4em; /* Large video icon */
            color: var(--text-secondary-light);
        }

        .image-card .image-info { padding: 15px; display:flex; flex-direction:column; flex-grow:1; }
        .image-card .image-name { 
            font-weight: 500; font-size: 0.9em; 
            color: var(--text-primary-light); 
            margin-bottom: 12px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; 
            cursor: default; border-bottom: none; padding-bottom: 0; 
        }
        
        .card-metadata-fields { margin-top: 0; margin-bottom: 15px; display: flex; flex-direction: column; gap: 12px; }
        .card-field { display: flex; flex-direction: column; position: relative; }
        
        .card-field-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 4px; 
        }
        .card-field-header label {
            font-size: 0.7em; font-weight: 600; 
            color: var(--text-secondary-light);
            text-transform: uppercase; 
        }
        .card-copy-btn {
            background: none; border: none;
            color: #adb5bd; font-size: 1em; 
            cursor: pointer; padding: 0px 3px; 
            line-height: 1;
            transition: color 0.2s;
        }
        .card-copy-btn:hover { color: var(--accent-primary-light); }
        .card-copy-btn .fa-check { color: var(--accent-success-light); }
        .card-copy-btn .fa-times { color: var(--accent-danger-light); }

        .editable-card-content {
            width: 100%; padding: 10px 12px; 
            background-color: var(--card-editable-bg); 
            border: 1px solid var(--card-editable-border);
            color: var(--text-primary-light);
            border-radius: 5px; 
            font-size: 0.85em; line-height: 1.5;
            min-height: 36px; 
            transition: border-color 0.2s, background-color 0.2s;
        }
        .editable-card-content:focus {
            background-color: var(--bg-secondary-light);
            border-color: var(--accent-primary-light);
            outline: none;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.12);
        }
        .editable-card-content[placeholder]:empty:before {
            content: attr(placeholder);
            color: #b0bac3; opacity: 1;
        }
        .editable-card-content[data-field="description"] { min-height: 54px; }
        
        .card-metadata-status { 
            font-size: 0.9em; font-weight: 500; padding: 12px 10px; 
            border-radius: 5px; text-align: center;
            margin-top: 0; margin-bottom: 15px; 
        }
        .card-metadata-status.loading {
            background-color: #eef7ff; color: var(--accent-primary-light);
            border: 1px dashed var(--accent-primary-light);
        }
        .card-metadata-status.error {
            background-color: #fff0f1; color: var(--accent-danger-light);
            border: 1px dashed var(--accent-danger-light);
        }

        .image-card.is-loading { animation: card-loading-pulse 1.5s infinite ease-in-out; }
        @keyframes card-loading-pulse {
            0% { box-shadow: 0 2px 5px rgba(0,0,0,0.07), 0 0 0 0px rgba(52, 152, 219, 0.15); }
            50% { box-shadow: 0 2px 5px rgba(0,0,0,0.07), 0 0 0 3px rgba(52, 152, 219, 0); }
            100% { box-shadow: 0 2px 5px rgba(0,0,0,0.07), 0 0 0 0px rgba(52, 152, 219, 0.15); }
        }

        .image-card .image-actions { 
            display: flex; gap: 10px; margin-top: auto;
            padding-top: 15px; border-top: 1px solid var(--card-editable-border); 
        }
        .image-card .image-actions .btn {
            flex: 1; padding: 10px 12px; font-size: 0.9em; font-weight: 500; 
            border-radius: 5px; border: none; color: white; 
            display: inline-flex; align-items: center; justify-content: center; gap: 6px;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
            text-decoration: none; cursor: pointer;
            box-shadow: 0 1px 2px rgba(0,0,0,0.06), 0 2px 3px rgba(0,0,0,0.06);
        }
        .image-card .image-actions .btn:hover { 
            transform: translateY(-2px); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.08), 0 4px 6px rgba(0,0,0,0.08);
        }
        .image-card .image-actions .btn:active { 
            transform: translateY(0px); 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.12);
        }
        .image-card .image-actions .btn.btn-info { background-color: var(--accent-info-light); }
        .image-card .image-actions .btn.btn-info:hover { background-color: #16a085; }
        .image-card .image-actions .btn.btn-danger { background-color: var(--accent-danger-light); }
        .image-card .image-actions .btn.btn-danger:hover { background-color: #c0392b; }

        .status-bar {
            display: flex; align-items: center; justify-content: space-between;
            padding: 15px 20px; border-radius: var(--border-radius-main);
            background-color: var(--bg-secondary-light); 
            box-shadow: 0 3px 10px var(--shadow-color-light); 
            margin-bottom: 25px;
        }
        .status-bar .progress-container {
            flex-grow: 1; margin-right: 20px;
        }
        .status-bar progress#progress-bar {
            width: 100%; height: 10px; border-radius: 5px;
            -webkit-appearance: none; appearance: none;
        }
        .status-bar progress#progress-bar::-webkit-progress-bar {
            background-color: var(--border-color-light); border-radius: 5px;
        }
        .status-bar progress#progress-bar::-webkit-progress-value {
            background-color: var(--accent-success-light); border-radius: 5px;
            transition: width 0.4s ease;
        }
        .status-bar progress#progress-bar::-moz-progress-bar {
            background-color: var(--accent-success-light); border-radius: 5px;
            transition: width 0.4s ease;
        }

        .btn {
            padding: 10px 18px; font-size: 0.95em; border-radius: 6px;
            border: none; cursor: pointer; font-weight: 500;
            transition: background-color 0.25s ease, transform 0.15s ease, box-shadow 0.2s ease;
            display: inline-flex; align-items: center; justify-content:center; gap: 8px;
            color: white; text-decoration: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.07);
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .btn:active { transform: translateY(0px) scale(0.97); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
        
        button#add-api-key-btn { background-color: var(--accent-primary-light); } 
        button#add-api-key-btn:hover { background-color: #2980b9; }
        .api-key-item .btn.btn-danger { 
            background-color: var(--accent-danger-light); 
            padding: 5px 10px; font-size: 0.8em;
        }
        .api-key-item .btn.btn-danger:hover { background-color: #c0392b; }

        .status-bar button#generate-all-metadata { background-color: var(--accent-success-light); } 
        .status-bar button#generate-all-metadata:hover { background-color: #27ae60; }
        .status-bar button#generate-all-metadata:disabled { background-color: #bdc3c7; color:#7f8c8d; box-shadow: none; cursor: not-allowed; }
        
        .export-section { 
            padding:15px; text-align:center; margin-top:0; 
            background:transparent; box-shadow:none;
        }
        .export-section button#export-csv { background-color: var(--text-secondary-light); } 
        .export-section button#export-csv:hover { background-color: #525E6A; }
        
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Adobe Stock Metadata Generator</h1>
        
        <div class="section api-keys-section">
            <h2>API Key Management</h2>
            <div class="form-group">
                <input type="text" id="api-key-input" placeholder="Enter your Gemini API key">
                <button id="add-api-key-btn" class="btn"><i class="fas fa-plus-circle"></i> Add Key</button>
            </div>
            <div class="api-key-list" id="api-key-list-container"></div>
            <p id="no-api-keys-message" class="text-center" style="color:var(--text-secondary-light); font-size:0.9em; display:none; margin-top:10px;">No API keys saved.</p>
        </div>

        <div class="section generation-settings-section">
            <div class="settings-header-wrapper">
                 <h2>Generation Settings</h2>
                 <p>Customize output. Applies to new generations.</p>
            </div>
            <div class="settings-groups-container">
                <div class="settings-group">
                    <h4>Title</h4>
                    <div class="setting-field">
                        <label for="setting-title-min">Min Chars:</label>
                        <input type="number" id="setting-title-min" min="10" max="200" value="70">
                    </div>
                    <div class="setting-field">
                        <label for="setting-title-max">Max Chars:</label>
                        <input type="number" id="setting-title-max" min="10" max="200" value="100">
                    </div>
                </div>
                <div class="settings-group">
                    <h4>Keywords</h4>
                    <div class="setting-field">
                        <label for="setting-keywords-min">Min Count:</label>
                        <input type="number" id="setting-keywords-min" min="5" max="49" value="15">
                    </div>
                    <div class="setting-field">
                        <label for="setting-keywords-max">Max Count:</label>
                        <input type="number" id="setting-keywords-max" min="5" max="49" value="30">
                    </div>
                </div>
                <div class="settings-group">
                    <h4>Description</h4>
                    <div class="setting-field">
                        <label for="setting-description-min-words">Min Words:</label>
                        <input type="number" id="setting-description-min-words" min="0" max="200" value="0">
                    </div>
                    <div class="setting-field">
                        <label for="setting-description-max-words">Max Words:</label>
                        <input type="number" id="setting-description-max-words" min="0" max="200" value="0">
                    </div>
                     <small>Set Min/Max to 0 for empty.</small>
                </div>
                <div class="settings-group" id="title-suffixes-group">
                    <h4>Title Suffixes</h4>
                    <div class="setting-field-checkbox">
                        <input type="checkbox" id="setting-suffix-transparent-bg">
                        <label for="setting-suffix-transparent-bg">Transparent BG</label>
                    </div>
                    <div class="setting-field-checkbox">
                        <input type="checkbox" id="setting-suffix-white-bg">
                        <label for="setting-suffix-white-bg">White BG</label>
                    </div>
                    <small>Appends to title. Select one.</small>
                </div>
            </div>
        </div>
        
        <div class="section image-upload-section"> <!-- ID and class kept for consistency, but it's now media -->
            <h2>Upload Media</h2> <!-- MODIFIED TEXT -->
            <div class="dropzone" id="dropzone">
                <i class="fas fa-cloud-upload-alt"></i>
                <p>Drag & drop images or videos here or click to select</p> <!-- MODIFIED TEXT -->
                <!-- MODIFIED: accept attribute to include video/* -->
                <input type="file" id="file-input" multiple accept="image/*,video/*" style="display: none;">
            </div>
            
            <div class="image-preview-container" id="image-preview-container-main"></div>
             <p id="no-files-message-main-grid" class="text-center" style="color:var(--text-secondary-light); display:block; margin-top:15px;">
                No media uploaded yet. <!-- MODIFIED TEXT -->
            </p>
        </div>
        
        <div class="status-bar">
            <div class="progress-container">
                <progress id="progress-bar" value="0" max="100"></progress>
            </div>
            <button id="generate-all-metadata" class="btn">Generate All Metadata</button>
        </div>
        
        <div class="export-section" style="padding:15px; text-align:center; margin-top:0; background:transparent; box-shadow:none;">
            <button id="export-csv" class="btn">Export to CSV</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lenis@1.0.45/dist/lenis.min.js"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const lenis = new Lenis({ duration: 1.2, easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)), smoothTouch: true });
        function raf(time) { lenis.raf(time); requestAnimationFrame(raf); }
        requestAnimationFrame(raf);

        gsap.to(".container", { opacity: 1, duration: 0.2 });
        gsap.from(".container > h1", { opacity:0, y:-20, duration:0.5, delay:0.1, ease:"power2.out"});
        gsap.from(".section, .status-bar", { opacity:0, y:20, duration:0.5, stagger:0.08, ease:"power2.out", delay:0.2 });
        
        let state = {
            apiKeys: JSON.parse(localStorage.getItem('advGenMeta_apiKeys_v3')) || [],
            currentApiKeyIndex: parseInt(localStorage.getItem('advGenMeta_currentApiKeyIndex_v3')) || 0,
            requestsCount: parseInt(localStorage.getItem('advGenMeta_requestsCount_v3')) || 0,
            // 'images' array now stores generic media items (image or video)
            images: [], // Consider renaming to mediaItems in a future refactor for clarity
            metadataSettings: { 
                titleMinChars: 70, titleMaxChars: 100, 
                keywordsMinCount: 15, keywordsMaxCount: 30, 
                descriptionMinWords: 0, descriptionMaxWords: 0, 
                suffixTransparentBg: false, 
                suffixWhiteBg: false,       
                category: "AdobeStock" 
            }
        };
        const GENERATION_SETTINGS_LS_KEY = 'advGenMeta_generationSettings_v5'; 

        const apiKeyInput = document.getElementById('api-key-input');
        const addApiKeyBtn = document.getElementById('add-api-key-btn');
        const apiKeyListContainer = document.getElementById('api-key-list-container');
        const noApiKeysMessage = document.getElementById('no-api-keys-message');
        
        const settingTitleMin = document.getElementById('setting-title-min');
        const settingTitleMax = document.getElementById('setting-title-max');
        const settingKeywordsMin = document.getElementById('setting-keywords-min');
        const settingKeywordsMax = document.getElementById('setting-keywords-max');
        const settingDescMinWords = document.getElementById('setting-description-min-words');
        const settingDescMaxWords = document.getElementById('setting-description-max-words');
        const settingSuffixTransparentBg = document.getElementById('setting-suffix-transparent-bg'); 
        const settingSuffixWhiteBg = document.getElementById('setting-suffix-white-bg');       

        const generationSettingsInputs = [
            settingTitleMin, settingTitleMax, 
            settingKeywordsMin, settingKeywordsMax, 
            settingDescMinWords, settingDescMaxWords,
            settingSuffixTransparentBg, settingSuffixWhiteBg
        ];

        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('file-input');
        const imagePreviewContainerMain = document.getElementById('image-preview-container-main'); // Name kept for now
        const noFilesMessageMainGrid = document.getElementById('no-files-message-main-grid');
        const progressBar = document.getElementById('progress-bar');
        const generateAllMetadataBtn = document.getElementById('generate-all-metadata');
        const exportCsvBtn = document.getElementById('export-csv');

        loadGenerationSettings();
        renderApiKeyList(); 
        updateGenerateButtonState(); 
        updateProgressBar(); 
        renderMediaCardGrid(); // MODIFIED: Renamed function call

        function saveApiKeysState() { localStorage.setItem('advGenMeta_apiKeys_v3', JSON.stringify(state.apiKeys)); localStorage.setItem('advGenMeta_currentApiKeyIndex_v3', state.currentApiKeyIndex.toString()); localStorage.setItem('advGenMeta_requestsCount_v3', state.requestsCount.toString()); }
        
        function saveGenerationSettings() {
            state.metadataSettings.titleMinChars = parseInt(settingTitleMin.value) || 70;
            state.metadataSettings.titleMaxChars = parseInt(settingTitleMax.value) || 100;
            state.metadataSettings.keywordsMinCount = parseInt(settingKeywordsMin.value) || 15;
            state.metadataSettings.keywordsMaxCount = parseInt(settingKeywordsMax.value) || 30;
            state.metadataSettings.descriptionMinWords = parseInt(settingDescMinWords.value) || 0;
            state.metadataSettings.descriptionMaxWords = parseInt(settingDescMaxWords.value) || 0;
            state.metadataSettings.suffixTransparentBg = settingSuffixTransparentBg.checked; 
            state.metadataSettings.suffixWhiteBg = settingSuffixWhiteBg.checked;         
            localStorage.setItem(GENERATION_SETTINGS_LS_KEY, JSON.stringify(state.metadataSettings));
        }

        function loadGenerationSettings() {
            const savedSettings = JSON.parse(localStorage.getItem(GENERATION_SETTINGS_LS_KEY));
            if (savedSettings) {
                state.metadataSettings.suffixTransparentBg = savedSettings.suffixTransparentBg || false;
                state.metadataSettings.suffixWhiteBg = savedSettings.suffixWhiteBg || false;
                state.metadataSettings = { ...state.metadataSettings, ...savedSettings }; 
            }
            settingTitleMin.value = state.metadataSettings.titleMinChars;
            settingTitleMax.value = state.metadataSettings.titleMaxChars;
            settingKeywordsMin.value = state.metadataSettings.keywordsMinCount;
            settingKeywordsMax.value = state.metadataSettings.keywordsMaxCount;
            settingDescMinWords.value = state.metadataSettings.descriptionMinWords;
            settingDescMaxWords.value = state.metadataSettings.descriptionMaxWords;
            settingSuffixTransparentBg.checked = state.metadataSettings.suffixTransparentBg; 
            settingSuffixWhiteBg.checked = state.metadataSettings.suffixWhiteBg;           
        }
        
        function truncate(str, num) { if (!str) return ''; if (str.length <= num) return str; return str.slice(0, num) + '...'; }
        
        function copyToClipboardOnCard(textToCopy, copyButtonElement) {
            if (!textToCopy && textToCopy !== "") { 
                 copyButtonElement.innerHTML = '<i class="fas fa-times"></i> Empty';
                 setTimeout(() => { copyButtonElement.innerHTML = '<i class="fas fa-copy"></i>'; }, 1500);
                return;
            }
            navigator.clipboard.writeText(textToCopy).then(() => {
                copyButtonElement.innerHTML = '<i class="fas fa-check"></i> Copied!';
                setTimeout(() => { copyButtonElement.innerHTML = '<i class="fas fa-copy"></i>'; }, 1500);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                copyButtonElement.innerHTML = '<i class="fas fa-times"></i> Error';
                setTimeout(() => { copyButtonElement.innerHTML = '<i class="fas fa-copy"></i>'; }, 1500);
            });
        }

        addApiKeyBtn.addEventListener('click', addApiKey); 
        generationSettingsInputs.forEach(input => input.addEventListener('change', () => {
            if (input.type === 'checkbox') {
                if (input.id === 'setting-suffix-transparent-bg' && input.checked) {
                    settingSuffixWhiteBg.checked = false;
                } else if (input.id === 'setting-suffix-white-bg' && input.checked) {
                    settingSuffixTransparentBg.checked = false;
                }
            }
            saveGenerationSettings();
        }));
        dropzone.addEventListener('click', () => fileInput.click());
        dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('active'); });
        dropzone.addEventListener('dragleave', () => { dropzone.classList.remove('active'); });
        dropzone.addEventListener('drop', (e) => { e.preventDefault(); dropzone.classList.remove('active'); handleFiles(e.dataTransfer.files); });
        fileInput.addEventListener('change', () => { if (fileInput.files.length > 0) { handleFiles(fileInput.files); } });
        generateAllMetadataBtn.addEventListener('click', generateAllMetadata); 
        exportCsvBtn.addEventListener('click', exportToCsv); 

        function addApiKey() { const key = apiKeyInput.value.trim(); if (key && !state.apiKeys.includes(key)) { state.apiKeys.push(key); if (state.apiKeys.length === 1) { state.currentApiKeyIndex = 0; state.requestsCount = 0; } saveApiKeysState(); renderApiKeyList(); apiKeyInput.value = ''; updateGenerateButtonState(); } else if (!key) { alert("API key cannot be empty."); } else { alert("This API key is already added."); } }
        function removeApiKey(indexToRemove) { state.apiKeys.splice(indexToRemove, 1); if (state.currentApiKeyIndex >= indexToRemove) { state.currentApiKeyIndex = Math.max(0, state.currentApiKeyIndex - 1); if (state.apiKeys.length > 0 && state.currentApiKeyIndex >= state.apiKeys.length) { state.currentApiKeyIndex = state.apiKeys.length - 1; } state.requestsCount = 0; } if (state.apiKeys.length === 0) { state.currentApiKeyIndex = 0; state.requestsCount = 0; } saveApiKeysState(); renderApiKeyList(); updateGenerateButtonState(); }
        function renderApiKeyList() { apiKeyListContainer.innerHTML = ''; noApiKeysMessage.style.display = state.apiKeys.length === 0 ? 'block' : 'none'; state.apiKeys.forEach((key, index) => { const keyItem = document.createElement('div'); keyItem.className = 'api-key-item'; if (index === state.currentApiKeyIndex) keyItem.classList.add('active-api-key'); const keyTextSpan = document.createElement('span'); keyTextSpan.textContent = `Key ending in: ••••${key.slice(-4)} ${index === state.currentApiKeyIndex ? '(Active)' : ''}`; keyItem.addEventListener('click', (e) => { if (!e.target.closest('.btn-danger')) { if (state.currentApiKeyIndex !== index) { state.currentApiKeyIndex = index; state.requestsCount = 0; saveApiKeysState(); renderApiKeyList(); } } }); const removeBtn = document.createElement('button'); removeBtn.className = 'btn btn-danger'; removeBtn.innerHTML = '<i class="fas fa-trash"></i> Remove'; removeBtn.addEventListener('click', (e) => { e.stopPropagation(); removeApiKey(index); }); keyItem.appendChild(keyTextSpan); keyItem.appendChild(removeBtn); apiKeyListContainer.appendChild(keyItem); }); }
        function getNextApiKey() { if (state.apiKeys.length === 0) return null; if (state.requestsCount >= 14 && state.apiKeys.length > 0) { state.currentApiKeyIndex = (state.currentApiKeyIndex + 1) % state.apiKeys.length; state.requestsCount = 0; renderApiKeyList(); } state.requestsCount++; saveApiKeysState(); return state.apiKeys[state.currentApiKeyIndex]; }

        function handleFiles(files) {
            let newMediaAdded = false; const filePromises = []; // MODIFIED: newImagesAdded -> newMediaAdded
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                // MODIFIED: Check for image OR video
                if (file.type.startsWith('image/') || file.type.startsWith('video/')) {
                    newMediaAdded = true;
                    filePromises.push(new Promise((resolveReader) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const mediaId = Date.now() + i + Math.random().toString(36).substring(2);
                            // MODIFIED: Add mediaType property
                            const mediaType = file.type.startsWith('image/') ? 'image' : 'video';
                            const mediaData = { 
                                id: mediaId, 
                                name: file.name, 
                                file: file, 
                                url: e.target.result, // Data URL for both image and video
                                size: file.size, 
                                originalType: file.type, // Store full original mime type
                                type: file.type.split('/')[1].toUpperCase(), // e.g., JPEG, MP4
                                mediaType: mediaType, // 'image' or 'video'
                                metadata: null, 
                                error: null, 
                                loading: false, 
                                attempts: 0 
                            };
                            resolveReader(mediaData);
                        };
                        reader.readAsDataURL(file);
                    }));
                }
            }
            if (newMediaAdded) {
                Promise.all(filePromises).then(mediaDataArray => {
                    const newlyAddedMediaIds = [];
                    mediaDataArray.forEach(mediaData => { 
                        state.images.push(mediaData); // 'images' array now holds mediaData
                        newlyAddedMediaIds.push(mediaData.id); 
                    });
                    renderMediaCardGrid(newlyAddedMediaIds); // MODIFIED: Function call
                    updateGenerateButtonState(); 
                    updateProgressBar();
                });
            }
            fileInput.value = '';
        }

        // MODIFIED: Renamed function and parameter
        function updateSingleMediaCardContent(cardElement, mediaItem) {
            cardElement.classList.toggle('is-loading', !!mediaItem.loading);
            const metadataFieldsContainer = cardElement.querySelector('.card-metadata-fields');
            const titleField = metadataFieldsContainer.querySelector('.editable-card-content[data-field="title"]');
            const keywordsField = metadataFieldsContainer.querySelector('.editable-card-content[data-field="keywords"]');
            const descriptionField = metadataFieldsContainer.querySelector('.editable-card-content[data-field="description"]');
            let statusDiv = cardElement.querySelector('.card-metadata-status');
            if (statusDiv) statusDiv.remove(); 

            if (mediaItem.loading) {
                metadataFieldsContainer.style.display = 'none'; 
                statusDiv = document.createElement('div');
                statusDiv.className = 'card-metadata-status loading';
                statusDiv.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Generating...`;
                const nameDiv = cardElement.querySelector('.image-name'); // Class name kept for now
                if (nameDiv) nameDiv.parentNode.insertBefore(statusDiv, metadataFieldsContainer);
                else cardElement.querySelector('.image-info').insertBefore(statusDiv, metadataFieldsContainer);
            } else if (mediaItem.error) {
                metadataFieldsContainer.style.display = 'none'; 
                statusDiv = document.createElement('div');
                statusDiv.className = 'card-metadata-status error';
                statusDiv.innerHTML = `<i class="fas fa-exclamation-triangle"></i> Error: ${truncate(mediaItem.error, 40)}`;
                const nameDiv = cardElement.querySelector('.image-name');
                 if (nameDiv) nameDiv.parentNode.insertBefore(statusDiv, metadataFieldsContainer);
                else cardElement.querySelector('.image-info').insertBefore(statusDiv, metadataFieldsContainer);
            } else { 
                metadataFieldsContainer.style.display = 'flex'; 
                if (mediaItem.metadata) {
                    titleField.textContent = mediaItem.metadata.title || '';
                    keywordsField.textContent = mediaItem.metadata.keywords || '';
                    descriptionField.textContent = mediaItem.metadata.description || '';
                } else { 
                    titleField.textContent = '';
                    keywordsField.textContent = '';
                    descriptionField.textContent = '';
                }
            }
            const regenBtn = cardElement.querySelector('.image-actions .btn.btn-info');
            if (regenBtn) {
                regenBtn.disabled = !!mediaItem.loading;
                 if (!mediaItem.loading && !regenBtn.innerHTML.includes('fa-sync-alt')) {
                    regenBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Regenerate';
                }
            }
        }

        // MODIFIED: Renamed function and parameter
        function renderMediaCardGrid(newMediaIdsToAnimate = []) {
            const cardsToAnimate = [];
            // state.images now contains media items
            state.images.forEach(mediaItem => {
                let card = imagePreviewContainerMain.querySelector(`.image-card[data-id="${mediaItem.id}"]`);
                if (!card) {
                    card = document.createElement('div'); card.className = 'image-card'; card.dataset.id = mediaItem.id;
                    if (newMediaIdsToAnimate.includes(mediaItem.id) && window.gsap) { 
                        card.style.opacity = "0"; card.style.transform = "scale(0.9)"; 
                        cardsToAnimate.push(card); 
                    }

                    // MODIFIED: Conditional rendering for image vs video placeholder
                    if (mediaItem.mediaType === 'image') {
                        let imgEl = document.createElement('img'); 
                        imgEl.src = mediaItem.url; 
                        imgEl.alt = mediaItem.name; 
                        card.appendChild(imgEl);
                    } else if (mediaItem.mediaType === 'video') {
                        let videoPlaceholder = document.createElement('div');
                        videoPlaceholder.className = 'media-placeholder'; // For common styling if any
                        videoPlaceholder.innerHTML = '<i class="fas fa-film"></i>'; // Font Awesome video icon
                        card.appendChild(videoPlaceholder);
                    }
                    
                    let infoDiv = document.createElement('div'); infoDiv.className = 'image-info'; 
                    let nameDiv = document.createElement('div'); nameDiv.className = 'image-name'; nameDiv.textContent = mediaItem.name; infoDiv.appendChild(nameDiv);
                    const fieldsHTML = `
                        <div class="card-metadata-fields">
                            <div class="card-field">
                                <div class="card-field-header"><label>Title</label><button class="card-copy-btn" data-field="title" title="Copy Title"><i class="fas fa-copy"></i></button></div>
                                <div class="editable-card-content" data-field="title" contenteditable="true" placeholder="Enter title..."></div>
                            </div>
                            <div class="card-field">
                                <div class="card-field-header"><label>Keywords (comma-separated)</label><button class="card-copy-btn" data-field="keywords" title="Copy Keywords"><i class="fas fa-copy"></i></button></div>
                                <div class="editable-card-content" data-field="keywords" contenteditable="true" placeholder="e.g. keyword1, keyword2"></div>
                            </div>
                            <div class="card-field">
                                <div class="card-field-header"><label>Description</label><button class="card-copy-btn" data-field="description" title="Copy Description"><i class="fas fa-copy"></i></button></div>
                                <div class="editable-card-content" data-field="description" contenteditable="true" placeholder="Enter description..."></div>
                            </div>
                        </div>`;
                    infoDiv.insertAdjacentHTML('beforeend', fieldsHTML);
                    infoDiv.querySelectorAll('.editable-card-content').forEach(editable => {
                        editable.addEventListener('input', (e) => {
                            const fieldName = e.target.dataset.field; const text = e.target.textContent;
                            const currentMediaItem = state.images.find(item => item.id === mediaItem.id);
                            if (currentMediaItem) { 
                                if (!currentMediaItem.metadata) currentMediaItem.metadata = { title: '', keywords: '', description: '' }; 
                                currentMediaItem.metadata[fieldName] = text; 
                                exportCsvBtn.disabled = state.images.length === 0 || !state.images.some(item => item.metadata); 
                            }
                        });
                    });
                    infoDiv.querySelectorAll('.card-copy-btn').forEach(button => {
                        button.addEventListener('click', (e) => { const fieldName = button.dataset.field; const editableContentDiv = button.closest('.card-field').querySelector('.editable-card-content'); copyToClipboardOnCard(editableContentDiv.textContent, button); });
                    });
                    let actionsDiv = document.createElement('div'); actionsDiv.className = 'image-actions'; 
                    let regenBtn = document.createElement('button'); 
                    regenBtn.className = 'btn btn-info'; 
                    regenBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Regenerate';
                    regenBtn.onclick = async () => { 
                        mediaItem.metadata = null; mediaItem.error = null; mediaItem.attempts = 0; 
                        card.querySelectorAll('.editable-card-content').forEach(el => el.textContent = ''); 
                        regenBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; regenBtn.disabled = true; 
                        await generateMetadataForSingleMedia(mediaItem); // MODIFIED: Function call
                        if (!mediaItem.loading) { 
                            regenBtn.innerHTML = '<i class="fas fa-sync-alt"></i> Regenerate'; 
                            regenBtn.disabled = false; 
                        } 
                    };
                    actionsDiv.appendChild(regenBtn);
                    let removeBtn = document.createElement('button'); 
                    removeBtn.className = 'btn btn-danger'; 
                    removeBtn.innerHTML = '<i class="fas fa-trash"></i> Remove'; 
                    removeBtn.onclick = () => removeSingleMedia(mediaItem.id); // MODIFIED: Function call
                    actionsDiv.appendChild(removeBtn);
                    infoDiv.appendChild(actionsDiv); card.appendChild(infoDiv); 
                    imagePreviewContainerMain.appendChild(card);
                }
                updateSingleMediaCardContent(card, mediaItem); // MODIFIED: Function call
            });
            Array.from(imagePreviewContainerMain.children).forEach(domCard => { 
                if (!state.images.find(item => item.id === domCard.dataset.id)) { domCard.remove(); } 
            });
            if (cardsToAnimate.length > 0 && window.gsap) { 
                gsap.to(cardsToAnimate, { opacity: 1, scale: 1, duration: 0.4, stagger: 0.07, ease: "power1.out" }); 
            }
            noFilesMessageMainGrid.style.display = state.images.length === 0 ? 'block' : 'none';
            updateProgressBar(); 
            updateGenerateButtonState(); 
            exportCsvBtn.disabled = state.images.length === 0 || !state.images.some(item => item.metadata);
        }

        // MODIFIED: Renamed function and parameter
        function removeSingleMedia(mediaId) { 
            const cardToRemove = imagePreviewContainerMain.querySelector(`.image-card[data-id="${mediaId}"]`);
            const onRemoveComplete = () => { 
                if (cardToRemove) cardToRemove.remove(); 
                state.images = state.images.filter(item => item.id !== mediaId); 
                updateGenerateButtonState(); updateProgressBar(); 
                noFilesMessageMainGrid.style.display = state.images.length === 0 ? 'block' : 'none'; 
            };
            if (cardToRemove && window.gsap) { 
                gsap.to(cardToRemove, { opacity: 0, scale: 0.8, duration: 0.3, ease: "power1.in", onComplete: onRemoveComplete }); // MODIFIED: onRemoveComplete -> onComplete for GSAP
            } else { 
                onRemoveComplete(); 
            }
        }

        async function generateAllMetadata() { 
            if (state.apiKeys.length === 0) { alert("Please add an API key."); return; } 
             const mediaToProcess = state.images.filter(item => !item.metadata && !item.error && !item.loading);
             if (mediaToProcess.length === 0) { 
                 if (state.images.some(item => item.error && !item.loading)) {
                    const erroredMedia = state.images.filter(item => item.error && !item.loading);
                    for (const mediaItem of erroredMedia) { 
                        if (mediaItem.error) { mediaItem.error = null; mediaItem.attempts = 0; } 
                        await generateMetadataForSingleMedia(mediaItem); // MODIFIED: Function call
                    }
                 } else { updateGenerateButtonState(); return; }
            }
            generateAllMetadataBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...'; generateAllMetadataBtn.disabled = true; 
            for (const mediaItem of mediaToProcess) { 
                if (mediaItem.error) { mediaItem.error = null; mediaItem.attempts = 0; } 
                await generateMetadataForSingleMedia(mediaItem); // MODIFIED: Function call
            } 
            updateGenerateButtonState();
        }

        // MODIFIED: Renamed function and parameter
        async function generateMetadataForSingleMedia(mediaItem) {
            if (state.apiKeys.length === 0) { 
                mediaItem.error = "No API key available."; mediaItem.loading = false; 
                const cardElement = imagePreviewContainerMain.querySelector(`.image-card[data-id="${mediaItem.id}"]`);
                if (cardElement) updateSingleMediaCardContent(cardElement, mediaItem); // MODIFIED: Function call
                return; 
            }
            mediaItem.loading = true; mediaItem.error = null; mediaItem.attempts = (mediaItem.attempts || 0) + 1;
            
            const cardElement = imagePreviewContainerMain.querySelector(`.image-card[data-id="${mediaItem.id}"]`);
            if (cardElement) updateSingleMediaCardContent(cardElement, mediaItem); // MODIFIED: Function call
            
            try {
                const apiKey = getNextApiKey(); if (!apiKey) throw new Error("No valid API Key.");
                
                let descriptionConstraint = "";
                const { descriptionMinWords, descriptionMaxWords } = state.metadataSettings;
                if (descriptionMinWords === 0 && descriptionMaxWords === 0) { descriptionConstraint = `Description: Generate an empty description.`; } 
                else if (descriptionMinWords === 0 && descriptionMaxWords > 0) { descriptionConstraint = `Description: Optionally, up to ${descriptionMaxWords} words (concise, compelling, relevant). If no strong description, generate an empty description.`; } 
                else if (descriptionMinWords > 0 && descriptionMaxWords >= descriptionMinWords) { descriptionConstraint = `Description: Between ${descriptionMinWords} and ${descriptionMaxWords} words (concise, compelling, relevant).`; } 
                else { descriptionConstraint = `Description: Generate an empty description.`; }

                // MODIFIED: Dynamically set "image" or "video" in the prompt
                const mediaTypeForPrompt = mediaItem.mediaType === 'video' ? 'video' : 'image';
                const prompt = `You are an expert in Adobe Stock metadata creation for the category "${state.metadataSettings.category}". Analyze the provided ${mediaTypeForPrompt}. Generate metadata based on these desired constraints:
- Title Length: Between ${state.metadataSettings.titleMinChars} and ${state.metadataSettings.titleMaxChars} characters.
- Keywords: Between ${state.metadataSettings.keywordsMinCount} and ${state.metadataSettings.keywordsMaxCount} relevant keywords (comma-separated, lowercase, singular).
- ${descriptionConstraint}
Format your response strictly:
Title: [title]
Keywords: [keywords]
Description: [description]`;

                const base64Media = await getBase64(mediaItem.file);
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ 
                        contents: [{ 
                            parts: [
                                { text: prompt }, 
                                { inline_data: { mime_type: mediaItem.originalType, data: base64Media.split(',')[1] } } // Use originalType for mime_type
                            ] 
                        }], 
                        generationConfig: { temperature: 0.45, topP: 0.95, topK: 40, maxOutputTokens: 1024 }, 
                        safetySettings: [ 
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" }, 
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" }, 
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" }, 
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" }, 
                        ] 
                    }) 
                });
                const data = await response.json();
                
                if (!response.ok || data.error) { 
                    let errorMessage = `API Error (${response.status})`; 
                    if (data.error?.message) errorMessage += `: ${data.error.message}`; 
                    const isApiKeyError = (response.status === 400 && data.error?.message.toLowerCase().includes("api key not valid")) || response.status === 429; 
                    if (isApiKeyError && state.apiKeys.length > 1 && mediaItem.attempts < 2 * state.apiKeys.length) { 
                        console.warn(`API error for key. Attempting next key for ${mediaItem.name}. Attempt: ${mediaItem.attempts}`); 
                        state.currentApiKeyIndex = (state.currentApiKeyIndex + 1) % state.apiKeys.length; 
                        state.requestsCount = 0; saveApiKeysState(); renderApiKeyList(); 
                        await new Promise(resolve => setTimeout(resolve, 500)); 
                        await generateMetadataForSingleMedia(mediaItem); // MODIFIED: Recursive call
                        return; 
                    } 
                    throw new Error(errorMessage); 
                }
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!text) { 
                    if (data.candidates?.[0]?.finishReason === "SAFETY") throw new Error('Blocked by API (safety).'); 
                    throw new Error('No metadata text from API.'); 
                }
                
                let parsedMetadata = parseMetadataResponse(text); 

                if (state.metadataSettings.suffixTransparentBg && parsedMetadata.title) {
                    parsedMetadata.title += " isolated on transparent background";
                } else if (state.metadataSettings.suffixWhiteBg && parsedMetadata.title) {
                    parsedMetadata.title += " isolated on white background";
                }
                if (parsedMetadata.title) {
                    parsedMetadata.title = parsedMetadata.title.replace(/\.\s*isolated/g, ' isolated').replace(/\.\./g, '.');
                }

                if (descriptionMinWords === 0 && descriptionMaxWords === 0 && parsedMetadata.description && parsedMetadata.description.trim() !== "") { 
                    parsedMetadata.description = ""; 
                }
                if (parsedMetadata.description && parsedMetadata.description.toLowerCase().includes("empty description")) { 
                    parsedMetadata.description = ""; 
                }

                if (!parsedMetadata.title || !parsedMetadata.keywords) { 
                    console.error("Failed to parse title/keywords. Raw API response:", text); 
                    throw new Error('Invalid metadata format from API (title/keywords missing).'); 
                }
                mediaItem.metadata = parsedMetadata; mediaItem.error = null;
            } catch (err) { 
                console.error('Error generating metadata for', mediaItem.name, ':', err); 
                mediaItem.error = err.message || 'Unknown generation error.'; 
            }
            finally {
                mediaItem.loading = false;
                if (cardElement) { updateSingleMediaCardContent(cardElement, mediaItem); } // MODIFIED: Function call
                updateGenerateButtonState(); 
                updateProgressBar();
                exportCsvBtn.disabled = state.images.length === 0 || !state.images.some(item => item.metadata);
            }
        }

        function parseMetadataResponse(text) { const titleMatch = text.match(/^Title:\s*(.+)$/im); const keywordsMatch = text.match(/^Keywords:\s*(.+)$/im); const descriptionMatch = text.match(/^Description:\s*(.*)$/im); return { title: titleMatch ? titleMatch[1].trim() : '', keywords: keywordsMatch ? keywordsMatch[1].trim() : '', description: descriptionMatch ? (descriptionMatch[1].trim() === "Generate an empty description." ? "" : descriptionMatch[1].trim()) : '' }; }
        function getBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }); }
        
        function exportToCsv() { 
            const mediaWithMetadata = state.images.filter(item => item.metadata); // MODIFIED variable name
            if (mediaWithMetadata.length === 0) { alert("No metadata available to export."); return; } 
            const rows = [['Filename', 'Title', 'Keywords', 'Description']]; 
            mediaWithMetadata.forEach(mediaItem => { // MODIFIED parameter name
                rows.push([ mediaItem.name, mediaItem.metadata.title || '', mediaItem.metadata.keywords || '', mediaItem.metadata.description || '' ]); 
            }); 
            const csvContent = rows.map(row => row.map(field => `"${field.toString().replace(/"/g, '""')}"`).join(',')).join('\n'); 
            const blob = new Blob(["\uFEFF" + csvContent], { type: 'text/csv;charset=utf-8;' }); 
            const url = URL.createObjectURL(blob); 
            const link = document.createElement('a'); link.setAttribute('href', url); link.setAttribute('download', `adobe_stock_metadata_${new Date().toISOString().slice(0,10)}.csv`); 
            document.body.appendChild(link); link.click(); document.body.removeChild(link); 
        }
        
        function updateGenerateButtonState() {
            // Logic remains largely the same, operating on state.images which now contains media items
            const mediaNeedingGeneration = state.images.filter(item => !item.metadata && !item.loading && !item.error).length;
            const erroredMedia = state.images.filter(item => item.error && !item.loading).length;
            const isLoading = state.images.some(item => item.loading);

            if (isLoading) { 
                generateAllMetadataBtn.disabled = true; 
                generateAllMetadataBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...'; 
            } else if (state.apiKeys.length === 0) { 
                generateAllMetadataBtn.disabled = true; 
                generateAllMetadataBtn.textContent = 'Add API Key'; 
            } else if (mediaNeedingGeneration > 0) { 
                generateAllMetadataBtn.disabled = false; 
                generateAllMetadataBtn.textContent = `Generate All (${mediaNeedingGeneration})`; 
            } else if (erroredMedia > 0) { 
                generateAllMetadataBtn.disabled = false; 
                generateAllMetadataBtn.textContent = `Retry ${erroredMedia} Errored`; 
            } else { 
                generateAllMetadataBtn.disabled = true; 
                generateAllMetadataBtn.textContent = 'Generate All Metadata'; 
            }
        }
        function updateProgressBar() { 
            const totalMedia = state.images.length; // MODIFIED variable name
            const processedMedia = state.images.filter(item => item.metadata || (item.error && !item.loading)).length; // MODIFIED variable name
            progressBar.max = totalMedia > 0 ? totalMedia : 100;
            const progressValue = totalMedia > 0 ? processedMedia : 0;
            if(window.gsap && progressBar.value !== progressValue) { 
                gsap.to(progressBar, {value: progressValue, duration:0.4, ease:"power1.out"});
            } else { 
                progressBar.value = progressValue; 
            }
        }

    });
    </script>
</body>
</html>